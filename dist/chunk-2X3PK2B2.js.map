{"version":3,"sources":["../src/internal/encodeAndDecodeSearchStrings.ts"],"names":["parseAndDecodeSearchString","searchParamsString","parseAsString","result","members","i","key","value","GLOBAL_CONFIG","decodePrimitive","parsedValue","encodeArrayForUrlParam","values","encodeIfStringOrNull","buildEncodedSearchString","params","b","parseSeparatorToCommas","paramsString"],"mappings":"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","file":"chunk-2X3PK2B2.js","sourcesContent":["import type { ParamsQuery } from \"./buildSearchParams\";\nimport { GLOBAL_CONFIG } from \"./config\";\nimport {\n  type PrimitivesInUrl,\n  decodePrimitive,\n  encodeIfStringOrNull,\n} from \"./encodeDecodePrimitives\";\n\nexport type parseAndDecodeSearchStringOptions<T> = {\n  /** This should be used for user inputs. User's could input numbers, nulls,\n   * or booleans breaking the usage of the primitive parser */\n  parseAsString?: (keyof T)[];\n};\n\nexport const parseAndDecodeSearchString = <T>(\n  searchParamsString: string,\n  { parseAsString }: parseAndDecodeSearchStringOptions<T> = {}\n): Partial<T> => {\n  const result: Record<string, unknown> = {};\n  const _searchString = searchParamsString.startsWith(\"?\")\n    ? searchParamsString.slice(1)\n    : searchParamsString;\n  const members = _searchString.split(\"&\");\n\n  for (let i = 0; i < members.length; i++) {\n    const [key, value] = members[i].split(\"=\");\n\n    if (value?.startsWith(GLOBAL_CONFIG.arraySeparator)) {\n      result[key] = value\n        .split(GLOBAL_CONFIG.arraySeparator)\n        .map(decodePrimitive)\n        .slice(1);\n    } else if (value && value !== \"undefined\") {\n      if (parseAsString?.includes(key as keyof T)) {\n        result[key] = value;\n      } else {\n        const parsedValue = decodePrimitive(value);\n\n        if (parsedValue === undefined) continue;\n\n        result[key] = parsedValue;\n      }\n    }\n  }\n\n  return result as Partial<T>;\n};\n\nexport const encodeArrayForUrlParam = (\n  values: PrimitivesInUrl[],\n  key?: string\n): string =>\n  !values.length\n    ? \"\"\n    : `${key ? `${key}=` : \"\"}${GLOBAL_CONFIG.arraySeparator}${values\n        .map(encodeIfStringOrNull)\n        .join(GLOBAL_CONFIG.arraySeparator)}`;\n\nexport const buildEncodedSearchString = (\n  params: Record<string, PrimitivesInUrl | PrimitivesInUrl[]>\n): string => {\n  const members = Object.entries(params).sort(([a], [b]) =>\n    a.toLowerCase() > b.toLowerCase() ? 1 : -1\n  );\n  const result: string[] = [];\n\n  for (let i = 0; i < members.length; i++) {\n    const [key, value] = members[i];\n\n    if (Array.isArray(value)) {\n      // If the array is empty, we don't want to include it in the query string\n      if (value.length) {\n        result.push(encodeArrayForUrlParam(value, key));\n      }\n    } else if (value !== undefined && value !== \"\") {\n      result.push(`${key}=${encodeIfStringOrNull(value)}`);\n    }\n  }\n\n  return `?${result.join(\"&\")}`;\n};\n\n/** \n  converts params to a string and replaces all instances of separator then removes any additional commas\n  default separator is '_._'\n */\nexport const parseSeparatorToCommas = (paramsString: string | ParamsQuery) => {\n  const stringToParse =\n    typeof paramsString !== \"string\" ? paramsString.toString() : paramsString;\n  return (\n    stringToParse\n      // ReplaceAll is not available\n      .split(`=${GLOBAL_CONFIG.arraySeparator}`)\n      .join(\"=\")\n      .split(GLOBAL_CONFIG.arraySeparator)\n      .join(\",\")\n  );\n};\n"]}